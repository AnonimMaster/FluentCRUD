# FluentCodeGenTool.Abstractions

This package provides shared abstractions for building code generation pipelines with [FluentCodeGenTool CLI](https://www.nuget.org/packages/FluentCodeGenTool/).

## Features

* Define custom generation steps via `IGenerationStep`
* Configure generation pipelines fluently
* Create reusable model metadata and annotations

## Example

```csharp
public class ProxyGenerator: IGenerationStep
{
	public IGenerationContext Generate(IStepContext context, IGenerationContext generationContext)
	{
		var templateContent = File.ReadAllText("...\\Templates\\ProxyTemplate.scriban");
		var template = Template.Parse(templateContent);
		
		if (template.HasErrors)
		{
			throw new InvalidOperationException($"Template errors: {string.Join(", ", template.Messages.Select(m => m.Message))}");
		}
		
		var model = new
		{
			entity = new
			{
				name = context.EntityType.Name,
				properties = context.Properties
					.Where(p => !p.Ignored)
					.Select(p => new
					{
						name = p.CustomName ?? p.PropertyInfo.Name,
						type = p.CustomType ?? p.PropertyInfo.PropertyType.Name,
					}).ToList()
			},
			@namespace = context.Namespace
		};
		
		var result = template.Render(model);
		
		return generationContext.AddFile($"{context.EntityType.Name}Proxy",context.Namespace,result);
	}
}
```

```csharp
public class User
{
	public Guid Id { get; set; }
	public string Name { get; set; } = "";
	public string Password { get; set; } = "";
	
	internal class Configurator: IModelGenerationConfigurator
	{
		public void Configuration(IGenerationPipeline pipeline)
		{
			pipeline
				.Step<ProxyGenerator>(step => step.For<User>(user =>
				{
					user.WithNamespace("TestNamespace");
				}));
		}
	}
}
```

## Use Case

Include this package in your model or domain project to define how code should be generated by the CLI tool.

## License

MIT
