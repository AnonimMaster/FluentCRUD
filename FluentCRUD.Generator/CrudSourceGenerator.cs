using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FluentCRUD.Generator;

[Generator]
public class CrudSourceGenerator: IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => IsIternalMap(node),
				transform: static (ctx, _) => Analyze(ctx))
			.Where(static t => t is not null);

		context.RegisterSourceOutput(classDeclarations, (ctx, data) =>
		{
			var (model, config) = data!.Value;
			
			ctx.ReportDiagnostic(Diagnostic.Create(
				new DiagnosticDescriptor(
					"FC002",
					"Generated model",
					"Model generated: {0}",
					"CodeGeneration",
					DiagnosticSeverity.Info,
					true),
				Location.None, model));
			
			Generate(ctx, model, config);
		});
	}
	
	static bool IsIternalMap(SyntaxNode node)
	{
		return node is ClassDeclarationSyntax cds &&
		       cds.Members.OfType<ClassDeclarationSyntax>().Any(m => m.Identifier.Text == "Map");
	}
	
	private static (ModelInfo, GenerationConfig)? Analyze(GeneratorSyntaxContext context)
	{
		if (context.Node is not ClassDeclarationSyntax outerClass) return null;
		var semanticModel = context.SemanticModel;
		var classSymbol = semanticModel.GetDeclaredSymbol(outerClass) as INamedTypeSymbol;
		if (classSymbol == null) return null;

		var mapClass = outerClass.Members
			.OfType<ClassDeclarationSyntax>()
			.FirstOrDefault(c => c.Identifier.Text == "Map");

		if (mapClass == null) return null;

		var modelInfo = new ModelInfo
		{
			TypeName = classSymbol.Name,
			Namespace = classSymbol.ContainingNamespace.ToDisplayString(),
			Properties = [
				..classSymbol.GetMembers()
					.OfType<IPropertySymbol>()
					.Where(p => !p.IsStatic)
			]
		};

		var config = new GenerationConfig(modelInfo)
		{
			// На практике ты бы анализировал тело метода Build(...) и извлекал аргументы
			// Здесь мы просто жёстко задаём параметры, как пример
			OverrideName = "UserProxy",
			TargetNamespace = "Game.Generated"
		};

		return (modelInfo, config);
	}

	protected static void BuildPipeline()
	{
		
	}
	
	private static void Generate(SourceProductionContext context, ModelInfo model, GenerationConfig config)
	{
		var className = config.OverrideName ?? model.TypeName + "Proxy";

		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine($"namespace {config.TargetNamespace};");
		sb.AppendLine($"public class {className}");
		sb.AppendLine("{");

		foreach (var prop in model.Properties)
		{
			sb.AppendLine($"    public {prop.Type.ToDisplayString()} {prop.Name} {{ get; set; }}");
		}

		sb.AppendLine("}");

		context.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}
}